var = "color"))
Sys.sleep(1)
print(timeStep)
}
# Count the number of individuals (males and females or both) at each time step
numInd <- numeric()
numMale <- numeric()
numFemale <- numeric()
t1 <- popInit
for(timeStep in 1:20){
# Movement
newFemales <- moveFemale(NLwith(agent = t1,
var = "sex",
val = "female"))
newMales <- moveMale(NLwith(agent = t1,
var = "sex",
val = "male"))
expect_equal(NLcount(newFemales) + NLcount(newMales),
NLcount(t1))
# Need to put back together the modified males and females for the next step (updated t1)
t1 <- turtleSet(newFemales,
newMales)
# Reproduction
whoReproducingFemales <- encounter(t1)
if(length(whoReproducingFemales) > 0){
popSize <- NLcount(t1)
t1 <- reproduction(allInd = t1,
whoReproducingFemales = whoReproducingFemales)
}
# Plot
plot(w1)
points(t1,
pch = 19,
col = of(agents = t1,
var = "color"))
Sys.sleep(1)
print(timeStep)
# Outputs
numInd <- c(numInd,
NLcount(t1))
numMale <- c(numMale,
NLcount(NLwith(agents = t1,
var = "sex",
val = "male")))
numFemale <- c(numFemale,
NLcount(NLwith(agents = t1,
var = "sex",
val = "female")))
}
# Plot the number of individuals
plot(1:20,
numInd,
ylim = c(0, max(numInd)),
main = "Number of individuals",
type = "l",
col = "green",
lwd = 2)
lines(1:20,
numMale,
col = "red")
lines(1:20,
numFemale,
col = "black")
library(doBy)
help(which.maxn)
help(NLdist)
library(NetLogoR)
help(NLdist)
library(NetLogoR)
set.seed(1234) # same seed so that everybody has the same results
## Setup
# Create the world
grass <- createWorld(minPxcor = -10,
maxPxcor = 10,
minPycor = -10,
maxPycor = 10,
data = 0)
# Create the sheep
sheep <- createTurtles(n = 50,
coords = randomXYcor(world = grass,
n = 50),
breed = "aSheep",
color = rep("red", 50))
# Create the wolves
wolves <- createTurtles(n = 20,
coords = randomXYcor(world = grass,
n = 20),
breed = "wolf",
color = rep("black",
20))
# Visualize the world
plot(grass)
points(sheep,
pch = 16,
col = "red")
points(wolves,
pch = 16,
col = "black")
## Functions used in the for loop
# Function with arguments "turtles" can be used by sheep and wolves
moveRandomly <- function(turtles, landscape, moveAngle) {
# Move one step in the direction between (- moveAngle) and (+ moveAngle)
turtles <- right(turtles = turtles,
angle = runif(n = NLcount(turtles),
min = -moveAngle,
max = moveAngle))
turtles <- fd(world = landscape,
turtles = turtles,
dist = 1,
torus = TRUE)
return(turtles)
}
reproduce <- function(turtles) {
# 10% of the individuals reproduce
repro <- runif(n = NLcount(turtles),
min = 0,
max = 100) < 10
whoTurtles <- of(agents = turtles,
var = "who") # "who" (ID) of all turtles
reproWho <- whoTurtles[repro] # "who" of turtles which reproduce
reproInd <- turtle(turtles,
who = reproWho) # turtles which reproduce
# if there is at least one individual reproducing
if (NLcount(reproInd) != 0) {
turtles <- hatch(turtles = turtles,
who = reproWho,
n = 1) # hatch one offspring per parent
}
return(turtles)
}
catchSheep <- function(landscape) {
# "who" numbers of sheep that are on the same patches as the wolves
sheepWolves <- turtlesOn(world = landscape,
turtles = sheep,
agents = wolves,
simplify = FALSE)
if(nrow(sheepWolves) != 0) {
sheepGrabbed <- oneOf(agents = sheepWolves) # grab one random sheep
sheep <- die(turtles = sheep,
who = sheepGrabbed) # kill the grabbed sheep
}
return(sheep)# return the object updated in this function
}
## For loop
time <- 0
maxTime <- 15
while((NLany(sheep) | NLany(wolves)) & time < maxTime) {
## as long as there are sheep or wolves in the world but with a maximum time step of 15
# Sheep
if (NLcount(sheep) != 0) {
sheep <- moveRandomly(turtles = sheep, landscape = grass, moveAngle = 50)
sheep <- reproduce(turtles = sheep)
}
# Wolves
wolves <- moveRandomly(turtles = wolves, landscape = grass, moveAngle = 50)
sheep <- catchSheep(landscape = grass) # the result returned is the "sheep"
wolves <- reproduce(turtles = wolves)
time <- time + 1
print(time)
# Slow the model
plot(grass)
points(sheep,
pch = 16,
col = "red")
points(wolves,
pch = 16,
col = "black")
Sys.sleep(.5)
}
library(NetLogoR)
set.seed(1234) # same seed so that everybody has the same results
## Setup
# Create the world
grass <- createWorld(minPxcor = -10,
maxPxcor = 10,
minPycor = -10,
maxPycor = 10,
data = 0)
# Create the sheep
sheep <- createTurtles(n = 50,
coords = randomXYcor(world = grass,
n = 50),
breed = "aSheep",
color = rep("red", 50))
# Create the wolves
wolves <- createTurtles(n = 20,
coords = randomXYcor(world = grass,
n = 20),
breed = "wolf",
color = rep("black",
20))
# Visualize the world
plot(grass)
points(sheep,
pch = 16,
col = "red")
points(wolves,
pch = 16,
col = "black")
## Functions used in the for loop
# Function with arguments "turtles" can be used by sheep and wolves
moveRandomly <- function(turtles, landscape, moveAngle) {
# Move one step in the direction between (- moveAngle) and (+ moveAngle)
turtles <- right(turtles = turtles,
angle = runif(n = NLcount(turtles),
min = -moveAngle,
max = moveAngle))
turtles <- fd(world = landscape,
turtles = turtles,
dist = 1,
torus = TRUE)
return(turtles)
}
# Example of moveRandomly
# Example of moveRandomly
sheep@.Data
wolves
# Example of moveRandomly
wolves@.Data
wolvesTest <- moveRandomly(turtles = wolves, landscape = grass, moveAngle = 0)
wolvesTest@.Data # turtles have move one step forward, their heading has not changed
wolvesTest <- moveRandomly(turtles = wolves, landscape = grass, moveAngle = 180)
wolvesTest@.Data # turtles have move one step in a new direction, their heading has changed
reproduce <- function(turtles) {
# 10% of the individuals reproduce
repro <- runif(n = NLcount(turtles),
min = 0,
max = 100) < 10
whoTurtles <- of(agents = turtles,
var = "who") # "who" (ID) of all turtles
reproWho <- whoTurtles[repro] # "who" of turtles which reproduce
reproInd <- turtle(turtles,
who = reproWho) # turtles which reproduce
# if there is at least one individual reproducing
if (NLcount(reproInd) != 0) {
turtles <- hatch(turtles = turtles,
who = reproWho,
n = 1) # hatch one offspring per parent
}
return(turtles)
}
# Example of reproduce
sheep
sheepTest <- reproduce(turtles = sheep)
sheep # new sheep added
sheepTest # new sheep added
catchSheep <- function(landscape) {
# "who" numbers of sheep that are on the same patches as the wolves
sheepWolves <- turtlesOn(world = landscape,
turtles = sheep,
agents = wolves,
simplify = FALSE)
if(nrow(sheepWolves) != 0) {
sheepGrabbed <- oneOf(agents = sheepWolves) # grab one random sheep
sheep <- die(turtles = sheep,
who = sheepGrabbed) # kill the grabbed sheep
}
return(sheep)# return the object updated in this function
}
# Example of catchSheep
sheep
sheepTest <- catchSheep(landscape = grass)
sheepTest # some sheep have died
catchSheep <- function(landscape, prey, predator) {
# "who" numbers of prey that are on the same patches as the predator
preypredator <- turtlesOn(world = landscape,
turtles = prey,
agents = predator,
simplify = FALSE)
if(nrow(sheepWolves) != 0) {
preyGrabbed <- oneOf(agents = preypredator) # grab one random prey
prey <- die(turtles = prey,
who = preyGrabbed) # kill the grabbed prey
}
return(prey)# return the object updated in this function
}
# Example of catchSheep
sheep
sheepTest <- catchSheep(landscape = grass, prey = sheep, predator = wolves)
catchSheep <- function(landscape, prey, predator) {
# "who" numbers of prey that are on the same patches as the predator
preypredator <- turtlesOn(world = landscape,
turtles = prey,
agents = predator,
simplify = FALSE)
if(nrow(preypredator) != 0) {
preyGrabbed <- oneOf(agents = preypredator) # grab one random prey
prey <- die(turtles = prey,
who = preyGrabbed) # kill the grabbed prey
}
return(prey)# return the object updated in this function
}
# Example of catchSheep
sheep
sheepTest <- catchSheep(landscape = grass, prey = sheep, predator = wolves)
sheepTest # some sheep have died
## WOLF SHEEP PREDATION ##
library(NetLogoR)
set.seed(1234) # same seed so that everybody has the same results
## Setup
# Create the world
grass <- createWorld(minPxcor = -10,
maxPxcor = 10,
minPycor = -10,
maxPycor = 10,
data = 0)
# Create the sheep
sheep <- createTurtles(n = 50,
coords = randomXYcor(world = grass,
n = 50),
breed = "aSheep",
color = rep("red", 50))
# Create the wolves
wolves <- createTurtles(n = 20,
coords = randomXYcor(world = grass,
n = 20),
breed = "wolf",
color = rep("black",
20))
# Visualize the world
plot(grass)
points(sheep,
pch = 16,
col = "red")
points(wolves,
pch = 16,
col = "black")
## Functions used in the for loop
# Function with arguments "turtles" can be used by sheep and wolves
moveRandomly <- function(turtles, landscape, moveAngle) {
# Move one step in the direction between (- moveAngle) and (+ moveAngle)
turtles <- right(turtles = turtles,
angle = runif(n = NLcount(turtles),
min = -moveAngle,
max = moveAngle))
turtles <- fd(world = landscape,
turtles = turtles,
dist = 1,
torus = TRUE)
return(turtles)
}
# Example of moveRandomly
wolves@.Data
wolvesTest <- moveRandomly(turtles = wolves, landscape = grass, moveAngle = 0)
wolvesTest@.Data # turtles have move one step forward, their heading has not changed
wolvesTest <- moveRandomly(turtles = wolves, landscape = grass, moveAngle = 180)
wolvesTest@.Data # turtles have move one step in a new direction, their heading has changed
reproduce <- function(turtles) {
# 10% of the individuals reproduce
repro <- runif(n = NLcount(turtles),
min = 0,
max = 100) < 10
whoTurtles <- of(agents = turtles,
var = "who") # "who" (ID) of all turtles
reproWho <- whoTurtles[repro] # "who" of turtles which reproduce
reproInd <- turtle(turtles,
who = reproWho) # turtles which reproduce
# if there is at least one individual reproducing
if (NLcount(reproInd) != 0) {
turtles <- hatch(turtles = turtles,
who = reproWho,
n = 1) # hatch one offspring per parent
}
return(turtles)
}
# Example of reproduce
sheep
sheepTest <- reproduce(turtles = sheep)
sheepTest # new sheep added
catchSheep <- function(prey, predator, landscape) {
# "who" numbers of prey that are on the same patches as the predator
preypredator <- turtlesOn(world = landscape,
turtles = prey,
agents = predator,
simplify = FALSE)
if(nrow(preypredator) != 0) {
preyGrabbed <- oneOf(agents = preypredator) # grab one random prey
prey <- die(turtles = prey,
who = preyGrabbed) # kill the grabbed prey
}
return(prey)# return the object updated in this function
}
# Example of catchSheep
sheep
sheepTest <- catchSheep(prey = sheep, predator = wolves, landscape = grass)
sheepTest # some sheep have died
## For loop
time <- 0
maxTime <- 15
while((NLany(sheep) | NLany(wolves)) & time < maxTime) {
## as long as there are sheep or wolves in the world but with a maximum time step of 15
# Sheep
if (NLcount(sheep) != 0) {
sheep <- moveRandomly(turtles = sheep, landscape = grass, moveAngle = 50)
sheep <- reproduce(turtles = sheep)
}
# Wolves
wolves <- moveRandomly(turtles = wolves, landscape = grass, moveAngle = 50)
sheep <- catchSheep(prey = sheep, predator = wolves, landscape = grass) # the result returned is the prey (sheep)
wolves <- reproduce(turtles = wolves)
time <- time + 1
print(time)
# Slow the model
plot(grass)
points(sheep,
pch = 16,
col = "red")
points(wolves,
pch = 16,
col = "black")
Sys.sleep(.5)
}
## DEBUG ##
library(NetLogoR)
# Unit tests with testthat
library(testthat)
set.seed(1234) # same seed so that everybody has the same results
runTests <- TRUE
# Forest model
# Create a forest of 25 cells representing 25 plots where trees can grow
# 1 tree per cell (= patch)
forest <- createWorld(minPxcor = 0,
maxPxcor = 4,
minPycor = 0,
maxPycor = 4)
# Trees are represented by their age (or it can be their size)
# Give a random age (between 1 and 10) to the 25 trees
forest <- NLset(world = forest,
agents = patches(forest),
val = sample(x = 1:10,
size = 25,
replace = TRUE))
# Run smoothly
if(runTests){
expect_true(all(of(agents = patches(forest),
world = forest) <= 11))
}
# Give error
if(runTests){
expect_true(all(of(agents = patches(forest),
world = forest) <= 2))
}
# Create a landscape over which mice evolve
# We use the forest from 1_ForestModel.R
forest <- createWorld(minPxcor = 0,
maxPxcor = 4,
minPycor = 0,
maxPycor = 4)
forest <- NLset(world = forest,
agents = patches(forest),
val = sample(x = 1:10,
size = 25,
replace = TRUE))
# Create a population of 6 mice
# Put the mice in the forest we just created
mice <- createTurtles(n = 6,
breed = "mouse",
world = forest)
# Give mice a sex, 3 "male" and 3 "female"
mice <- turtlesOwn(turtles = mice,
tVar = "sex",
tVal = c(rep("male", 3),
rep("female", 3)))
# Make the females produce 1 offspring each
mice <- hatch(turtles = mice,
who = of(agents = NLwith(agents = mice,
var = "sex",
val = "female"),
var = "who"),
n = 1,
breed = "offspring")
# Run smoothly
if(runTests){
expect_identical(of(agents = mice,
var = "breed"),
c(rep("mouse", 6), rep("offspring", 3)))
}
# Give error
if(runTests){
expect_identical(of(agents = mice,
var = "breed"),
c(rep("mouse", 7), rep("offspring", 4)))
}
# Give error
if(runTests){
expect_identical(of(agents = mice,
var = "breed"),
c(rep("mouse", 7), rep("offspring", 3)))
}
if(runTests){
expect_identical(of(agents = mice,
var = "breed"),
rep("mouse", 9))
}
help(sample)
# sample() (not from NetLogoR) does random sample and permutations
# Examples:
sample(x = 1:10, size = 5, replace = TRUE)
sample(x = 1:10, size = 5, replace = FALSE)
# sample() (not from NetLogoR) does random sample and permutations
# Examples:
sample(x = 1:10, size = 8, replace = TRUE)
# sample() (not from NetLogoR) does random sample and permutations
# Examples:
sample(x = 1:10, size = 15, replace = TRUE)
# sample() (not from NetLogoR) does random sample and permutations
# Examples:
sample(x = 1:10, size = 15, replace = FALSE)
sample(x = 10, size = 25, replace = TRUE)
sample(x = 10, size = 25, replace = FALSE)
sample(x = 10, size = 25)
help(runif)
