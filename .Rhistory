# Give a random age (between 1 and 10) to the 25 trees
forest <- NLset(world = forest, agents = patches(forest), val = sample(x = 1:10, size = 25, replace = TRUE))
plot(forest)
# What's in forest
forest
# Trees grow, their age increment of 1
ageTrees <- of(world = forest, agents = patches(forest))
newAgeTrees <- ageTrees + 1
forest <- NLset(world = forest, agents = patches(forest), val = newAgeTrees)
plot(forest)
# Cut 5 trees randomly (put their age at 0)
cutTrees <- nOf(agents = patches(forest), n = 5)
forest <- NLset(world = forest, agents = cutTrees, val = 0)
plot(forest)
# Create a landscape over which turtles evolve
# Forest from 1_ForestModel.R
forest <- createWorld(minPxcor = 0, maxPxcor = 4, minPycor = 0, maxPycor = 4)
forest <- NLset(world = forest, agents = patches(forest), val = sample(x = 1:10, size = 25, replace = TRUE))
plot(forest)
set.seed(1234) # same seed so that everybody has the same results
library(NetLogoR)
set.seed(1234) # same seed so that everybody has the same results
# Create a forest of 25 cells representing 25 plots where trees can grow (1 tree per cell)
forest <- createWorld(minPxcor = 0, maxPxcor = 4, minPycor = 0, maxPycor = 4)
plot(forest)
# Trees are represented by their age (or it can be their size)
# Give a random age (between 1 and 10) to the 25 trees
forest <- NLset(world = forest, agents = patches(forest), val = sample(x = 1:10, size = 25, replace = TRUE))
plot(forest)
# What's in forest
forest
# Trees grow, their age increment of 1
ageTrees <- of(world = forest, agents = patches(forest))
newAgeTrees <- ageTrees + 1
forest <- NLset(world = forest, agents = patches(forest), val = newAgeTrees)
plot(forest)
# Cut 5 trees randomly (put their age at 0)
cutTrees <- nOf(agents = patches(forest), n = 5)
forest <- NLset(world = forest, agents = cutTrees, val = 0)
plot(forest)
library(NetLogoR)
set.seed(1234) # same seed so that everybody has the same results
# Create a landscape over which mice evolve
# Forest from 1_ForestModel.R
forest <- createWorld(minPxcor = 0, maxPxcor = 4, minPycor = 0, maxPycor = 4)
forest <- NLset(world = forest, agents = patches(forest), val = sample(x = 1:10, size = 25, replace = TRUE))
plot(forest)
# Create a population of 6 mice
# Put the mice in the forest we just created
mice <- createTurtles(n = 6, world = w1)
points(mice, pch = 19, col = of(agents = mice, var = "color")) # all mice are in the center of the world
library(NetLogoR)
set.seed(1234) # same seed so that everybody has the same results
# Create a landscape over which mice evolve
# Forest from 1_ForestModel.R
forest <- createWorld(minPxcor = 0, maxPxcor = 4, minPycor = 0, maxPycor = 4)
forest <- NLset(world = forest, agents = patches(forest), val = sample(x = 1:10, size = 25, replace = TRUE))
plot(forest)
# Create a population of 6 mice
# Put the mice in the forest we just created
mice <- createTurtles(n = 6, world = forest)
points(mice, pch = 19, col = of(agents = mice, var = "color")) # all mice are in the center of the forest
# What's in mice
mice
# Access to the mice locations
mice@.Data # but labels or factor variables are no longer visible
# Move the mice randomly
# Their headings (directions) were randomly set when they were created
# Move mice forward of a step length of 0.5 (step =  resolution of the forest)
mice <- fd(turtles = mice, dist = 0.5, world = forest, torus = TRUE)
points(mice, pch = 19, col = of(agents = mice, var = "color"))
# Make them all rotate a 45 degrees angle to the right and move again 0.5 step
mice <- right(turtles = mice, angle = 45)
mice <- fd(turtles = mice, dist = 0.5, world = forest, torus = TRUE)
points(mice, pch = 19, col = of(agents = mice, var = "color"))
# Make them all rotate a 45 degrees angle to the left and move again 0.5 step
mice <- left(turtles = mice, angle = 45)
mice <- fd(turtles = mice, dist = 0.5, world = forest, torus = TRUE)
points(mice, pch = 19, col = of(agents = mice, var = "color"))
# Give mice an age, randomly between 1 and 5
mice <- turtlesOwn(turtles = mice, tVar = "age", tVal = sample(x = 1:5, size = 6, replace = TRUE))
mice
# Increment the mice age of 1
mice <- NLset(turtles = mice, agents = mice, var = "age", val = of(agents = mice, var = "age") + 1)
mice
# Give mice a sex, 3 "male" and 3 "female"
mice <- turtlesOwn(turtles = mice, tVar = "sex", tVal = c(rep("male", 3), rep("female", 3)))
mice
# Make the females produce 1 offspring each
mice <- hatch(turtles = mice, who = of(agents = NLwith(agents = mice, var = "sex", val = "female"), var = "who"),
n = 1, breed = "offspring")
mice
# Offspring inherit all the data from their mother
mice <- NLset(turtles = mice, agents = NLwith(agents = mice, var = "breed", val = "offspring"), var = c("age", "sex"),
val = cbind.data.frame(age = rep(0, 3), sex = sample(c("male", "female"), size = 3, replace = TRUE)))
# Kill the 3 oldest mice
ageTurtles <- of(agents = mice, var = c("who", "age"))
library(doBy)
turtlesToKill <- ageTurtles[, "who"][which.maxn(ageTurtles[, "age"], n = 3)]
mice <- die(turtles = mice, who = turtlesToKill)
mice
# Create a population of 6 mice
# Put the mice in the forest we just created
mice <- createTurtles(n = 6, breed = "mouse", world = forest)
mice
help(fd)
library(NetLogoR)
set.seed(1234) # same seed so that everybody has the same results
# Create a world with the desired extent
hill <- createWorld(minPxcor = 1,
maxPxcor = 100,
minPycor = 1,
maxPycor = 100)
# Define the patches values
# Elevation decreases linearly with distance from the center of the hill
# Hill center is at (30,30)
# The hill is 100 units high
elevation <- 100 - NLdist(agents = patches(hill),
agents2 = cbind(x = 30,
y = 30))
# Assign the elevation values to the patches
hill <- NLset(world = hill,
agents = patches(hill),
val = elevation)
# Visualize the world
plot(hill)
# Create turtles (50 butterflies in this model)
# The butterflies initial location are at the top of the hill at [30;30]
b3 <- createTurtles(n = 50,
coords = cbind(xcor = 30,
ycor = 30))
# Visualize the butterflies
points(b3,
pch = 16,
col = of(agents = b3,
var = "color"))
# What's inside this loop will be iterated 100 times
for (time in 1:100) {
# With a probability of 0.5
if (runif(n = 1, min = 0, max = 1) < 0.5) {
# Either move all butterflies downhill considering the 8 neighboring patches
# i.e., move each butterfly to the patch with the lowest (elevation) value among the 8 patches around
b3 <- downhill(world = hill,
turtles = b3,
nNeighbors = 8)
} else {
# Or move all butterflies to one of its neighboring patches at random
# First, identify for each butterfly the 8 patches around each one
allNeighbors <- neighbors(world = hill,
agents = b3,
nNeighbors = 8)
# Second, for each set of "neighboring patches", select one randomly
oneNeighbor <- oneOf(allNeighbors)
# Finally, move the butterflies to their randomly selected neighboring patch
b3 <- moveTo(turtles = b3,
agents = oneNeighbor)
}
# Visualize each new position for t1
points(b3,
pch = 16,
col = of(agents = b3,
var = "color"))
# Wait 1 second between each loop to see the butterflies moving
Sys.sleep(1)
}
help("createWorld")
# Create a 3-layer world of 15 patches
# Don't hesitate to use the help()
help("createWorld")
# Stack the 3 layers
help("stackWorlds")
# Create a population of 10 individuals,
# all at the location [0;0] and
# with their heading either North or South, randomly.
# Don't hesitate to use help()
help("createTurtles")
# Give them all an age of 5
help("turtlesOwn")
library(NetLogoR)
set.seed(1234) # same seed so that everybody has the same results
# Create the world
grass <- createWorld(minPxcor = -25,
maxPxcor = 25,
minPycor = -25,
maxPycor = 25,
data = 0)
# Create the sheep
sheep <- createTurtles(n = 100,
coords = randomXYcor(world = grass,
n = 100),
breed = "aSheep",
color = rep("red", 100))
# Create the wolves
wolves <- createTurtles(n = 50,
coords = randomXYcor(world = grass,
n = 50),
breed = "wolf",
color = rep("black",
50))
# Visualize the world
plot(grass)
points(sheep, pch = 16, col = "red")
points(wolves, pch = 16, col = "black")
library(NetLogoR)
set.seed(1234) # same seed so that everybody has the same results
# Create the world
grass <- createWorld(minPxcor = -25,
maxPxcor = 25,
minPycor = -25,
maxPycor = 25,
data = 0)
# Create the sheep
sheep <- createTurtles(n = 100,
coords = randomXYcor(world = grass,
n = 100),
breed = "aSheep",
color = rep("red", 100))
# Create the wolves
wolves <- createTurtles(n = 50,
coords = randomXYcor(world = grass,
n = 50),
breed = "wolf",
color = rep("black",
50))
plot(grass)
points(sheep, pch = 16, col = "red")
points(wolves, pch = 16, col = "black")
move <- function(turtles) {
# Move one step in the direction between -50 and +50
turtles <- right(turtles = turtles,
angle = runif(n = NLcount(turtles),
min = -50,
max = 50))
turtles <- fd(world = grass,
turtles = turtles,
dist = 1,
torus = TRUE)
return(turtles)
}
reproduce <- function(turtles) {
# 50% of the individuals reproduce
repro <- runif(n = NLcount(turtles),
min = 0,
max = 100) < 50
whoTurtles <- of(agents = turtles,
var = "who") # "who" (ID) of all turtles
reproWho <- whoTurtles[repro] # "who" of turtles which reproduce
reproInd <- turtle(turtles,
who = reproWho) # turtles which reproduce
# if there is at least one individual reproducing
if (NLcount(reproInd) != 0) {
turtles <- hatch(turtles = turtles,
who = reproWho,
n = 1) # hatch one offspring per parent
}
return(turtles)
}
catchSheep <- function() {
# "who" numbers of sheep that are on the same patches as the wolves
sheepWolves <- turtlesOn(world = grass,
turtles = sheep,
agents = wolves,
simplify = FALSE)
if (nrow(sheepWolves) != 0) {
sheepGrabbed <- oneOf(agents = sheepWolves) # grab one random sheep
sheep <- die(turtles = sheep,
who = sheepGrabbed) # kill the grabbed sheep
}
return(sheep)# return the object updated in this function
}
time <- 0
maxTime <- 500
## For loop
time <- 0
maxTime <- 50
# Sheep
if (NLcount(sheep) != 0) {
sheep <- move(sheep)
sheep <- reproduce(sheep)
}
# Wolves
wolves <- move(wolves)
sheep <- catchSheep() # the result returned is the "sheep"
wolves <- reproduce(wolves)
time <- time + 1
print(time) # slow the model
## Setup
# Create the world
grass <- createWorld(minPxcor = -25,
maxPxcor = 25,
minPycor = -25,
maxPycor = 25,
data = 0)
# Create the sheep
sheep <- createTurtles(n = 100,
coords = randomXYcor(world = grass,
n = 100),
breed = "aSheep",
color = rep("red", 100))
# Create the wolves
wolves <- createTurtles(n = 50,
coords = randomXYcor(world = grass,
n = 50),
breed = "wolf",
color = rep("black",
50))
time <- 0
maxTime <- 50
while ((NLany(sheep) | NLany(wolves)) & time < maxTime) {
## as long as there are sheep or wolves in the world but with a maximum time step at 50
# Sheep
if (NLcount(sheep) != 0) {
sheep <- move(sheep)
sheep <- reproduce(sheep)
}
# Wolves
wolves <- move(wolves)
sheep <- catchSheep() # the result returned is the "sheep"
wolves <- reproduce(wolves)
time <- time + 1
print(time)
# Slow the model
plot(grass)
points(sheep, pch = 16, col = "red")
points(wolves, pch = 16, col = "black")
}
library(NetLogoR)
set.seed(1234) # same seed so that everybody has the same results
## Setup
# Create the world
grass <- createWorld(minPxcor = -10,
maxPxcor = 10,
minPycor = -10,
maxPycor = 10,
data = 0)
# Create the sheep
sheep <- createTurtles(n = 50,
coords = randomXYcor(world = grass,
n = 50),
breed = "aSheep",
color = rep("red", 50))
# Create the wolves
wolves <- createTurtles(n = 20,
coords = randomXYcor(world = grass,
n = 20),
breed = "wolf",
color = rep("black",
20))
# Visualize the world
plot(grass)
points(sheep, pch = 16, col = "red")
points(wolves, pch = 16, col = "black")
## Functions used in the for loop
# Function with arguments "turtles" can be used by sheep and wolves
move <- function(turtles) {
# Move one step in the direction between -50 and +50
turtles <- right(turtles = turtles,
angle = runif(n = NLcount(turtles),
min = -50,
max = 50))
turtles <- fd(world = grass,
turtles = turtles,
dist = 1,
torus = TRUE)
return(turtles)
}
reproduce <- function(turtles) {
# 50% of the individuals reproduce
repro <- runif(n = NLcount(turtles),
min = 0,
max = 100) < 50
whoTurtles <- of(agents = turtles,
var = "who") # "who" (ID) of all turtles
reproWho <- whoTurtles[repro] # "who" of turtles which reproduce
reproInd <- turtle(turtles,
who = reproWho) # turtles which reproduce
# if there is at least one individual reproducing
if (NLcount(reproInd) != 0) {
turtles <- hatch(turtles = turtles,
who = reproWho,
n = 1) # hatch one offspring per parent
}
return(turtles)
}
catchSheep <- function() {
# "who" numbers of sheep that are on the same patches as the wolves
sheepWolves <- turtlesOn(world = grass,
turtles = sheep,
agents = wolves,
simplify = FALSE)
if (nrow(sheepWolves) != 0) {
sheepGrabbed <- oneOf(agents = sheepWolves) # grab one random sheep
sheep <- die(turtles = sheep,
who = sheepGrabbed) # kill the grabbed sheep
}
return(sheep)# return the object updated in this function
}
## For loop
time <- 0
maxTime <- 15
while ((NLany(sheep) | NLany(wolves)) & time < maxTime) {
## as long as there are sheep or wolves in the world but with a maximum time step at 50
# Sheep
if (NLcount(sheep) != 0) {
sheep <- move(sheep)
sheep <- reproduce(sheep)
}
# Wolves
wolves <- move(wolves)
sheep <- catchSheep() # the result returned is the "sheep"
wolves <- reproduce(wolves)
time <- time + 1
print(time)
# Slow the model
plot(grass)
points(sheep, pch = 16, col = "red")
points(wolves, pch = 16, col = "black")
Sys.sleep(1)
}
## Setup
# Create the world
grass <- createWorld(minPxcor = -10,
maxPxcor = 10,
minPycor = -10,
maxPycor = 10,
data = 0)
# Create the sheep
sheep <- createTurtles(n = 50,
coords = randomXYcor(world = grass,
n = 50),
breed = "aSheep",
color = rep("red", 50))
# Create the wolves
wolves <- createTurtles(n = 20,
coords = randomXYcor(world = grass,
n = 20),
breed = "wolf",
color = rep("black",
20))
# Visualize the world
plot(grass)
points(sheep, pch = 16, col = "red")
points(wolves, pch = 16, col = "black")
## Functions used in the for loop
# Function with arguments "turtles" can be used by sheep and wolves
move <- function(turtles) {
# Move one step in the direction between -50 and +50
turtles <- right(turtles = turtles,
angle = runif(n = NLcount(turtles),
min = -50,
max = 50))
turtles <- fd(world = grass,
turtles = turtles,
dist = 1,
torus = TRUE)
return(turtles)
}
reproduce <- function(turtles) {
# 10% of the individuals reproduce
repro <- runif(n = NLcount(turtles),
min = 0,
max = 100) < 10
whoTurtles <- of(agents = turtles,
var = "who") # "who" (ID) of all turtles
reproWho <- whoTurtles[repro] # "who" of turtles which reproduce
reproInd <- turtle(turtles,
who = reproWho) # turtles which reproduce
# if there is at least one individual reproducing
if (NLcount(reproInd) != 0) {
turtles <- hatch(turtles = turtles,
who = reproWho,
n = 1) # hatch one offspring per parent
}
return(turtles)
}
catchSheep <- function() {
# "who" numbers of sheep that are on the same patches as the wolves
sheepWolves <- turtlesOn(world = grass,
turtles = sheep,
agents = wolves,
simplify = FALSE)
if (nrow(sheepWolves) != 0) {
sheepGrabbed <- oneOf(agents = sheepWolves) # grab one random sheep
sheep <- die(turtles = sheep,
who = sheepGrabbed) # kill the grabbed sheep
}
return(sheep)# return the object updated in this function
}
## For loop
time <- 0
maxTime <- 15
while ((NLany(sheep) | NLany(wolves)) & time < maxTime) {
## as long as there are sheep or wolves in the world but with a maximum time step at 50
# Sheep
if (NLcount(sheep) != 0) {
sheep <- move(sheep)
sheep <- reproduce(sheep)
}
# Wolves
wolves <- move(wolves)
sheep <- catchSheep() # the result returned is the "sheep"
wolves <- reproduce(wolves)
time <- time + 1
print(time)
# Slow the model
plot(grass)
points(sheep, pch = 16, col = "red")
points(wolves, pch = 16, col = "black")
Sys.sleep(1)
}
sheep
wolves
