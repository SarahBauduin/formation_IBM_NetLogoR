females <- NLwith(agents = mice, var = "sex", val = "female")
offspring <- NLwith(agents = mice, var = "breed", val = "offspring")
expect_identical(NLcount(females), NLcount(offspring))
}
## FINAL GROUP EXERCISE ##
## Create a population of moving individuals where males and females have a different movement pattern
library(NetLogoR)
library(testthat)
rm(list=ls()) # reset the R environment
set.seed(1234) # same seed so that everybody has the same results
## EXERCISE 1/3 ##
# Create a world
w1 <- createWorld(minPxcor = 1,
maxPxcor = 10,
minPycor = 1,
maxPycor = 10,
data = runif(n = 100))
plot(w1)
# Create a population with males and females
t1 <- createTurtles(n = 30,
coords = randomXYcor(world = w1,
n = 30))
t1 <- turtlesOwn(turtles = t1,
tVar = "sex",
tVal = c(rep("male", 15), rep("female", 15)))
t1 <- NLset(turtles = t1,
agents = t1,
var = "color",
val = c(rep("red", 15), rep("black", 15)))
points(t1,
pch = 19,
col = of(agents = t1,
var = "color"))
popInit <- t1 # keep in memory for later
# Define 2 movement patterns/functions
moveFemale <- function(movingInd){
# Move randomly two steps in any direction
movingInd <- right(turtles = movingInd,
angle = runif(n = NLcount(movingInd),
min = 0,
max = 360))
movingInd <- fd(turtles = movingInd,
dist = 2,
world = w1,
torus = TRUE)
return(movingInd)
}
moveMale <- function(movingInd){
# Move to one of the 8 neighboring cells where there is a female on it, otherwise randomly
allNeighbors <- neighbors(world = w1,
agents = movingInd,
nNeighbors = 8)
patchFemale <- patchHere(world = w1,
turtles = NLwith(agents = t1,
var = "sex",
val = "female"))
patchFemale <- cbind(patchFemale,
femaleHere = 1)
allNeighborsFem <- merge(allNeighbors,
patchFemale,
all.x = TRUE)
allNeighborsFem[is.na(allNeighborsFem$femaleHere), "femaleHere"] <- 0
selectPatches <- cbind(pxcor = numeric(),
pycor = numeric())
for(each in unique(allNeighborsFem$id)){ # for each moving individual
if(sum(allNeighborsFem[allNeighborsFem$id == each, "femaleHere"]) == 0){ # if there are no female around
# Move to one cell at random
selectPatches <- rbind(selectPatches,
oneOf(as.matrix(allNeighborsFem[allNeighborsFem$id == each, c("pxcor", "pycor")])))
} else if(sum(allNeighborsFem[allNeighborsFem$id == each, "femaleHere"]) == 1){ # if there is only one female around
# Move to the cell with females on it
selectPatches <- rbind(selectPatches,
allNeighborsFem[allNeighborsFem$id == each &
allNeighborsFem$femaleHere == 1, c("pxcor", "pycor"), drop = FALSE])
} else { # if there are more than 1 female around
# Move to one cell with a female on it randomly among those that have females on it
selectPatches <- rbind(selectPatches,
oneOf(as.matrix(allNeighborsFem[allNeighborsFem$id == each &
allNeighborsFem$femaleHere == 1, c("pxcor", "pycor")])))
}
}
# Move the individuals to the chosen patches
movingInd <- moveTo(turtles = movingInd,
agents = as.matrix(selectPatches))
return(movingInd)
}
# Create a loop where males move with one movement function and female with the other one
for(timeStep in 1:20){
newFemales <- moveFemale(NLwith(agent = t1,
var = "sex",
val = "female"))
newMales <- moveMale(NLwith(agent = t1,
var = "sex",
val = "male"))
expect_equal(NLcount(newFemales) + NLcount(newMales),
NLcount(t1))
# Need to put back together the modified males and females for the next step (updated t1)
t1 <- turtleSet(newFemales,
newMales)
}
## EXERCISE 2/3 ##
## Make reproduction happens when a male meets a female, with the production of one offspring
# Define a reproduction function which produces an offspring
reproduction <- function(allInd, whoReproducingFemales){
popSize <- NLcount(allInd) # for the test
# Check that whoReproducingFemales are females'ID
expect_true(all(of(agents = turtle(turtles = allInd,
who = whoReproducingFemales),
var = "sex") == "female"))
allInd <- hatch(turtles = allInd,
who = whoReproducingFemales,
n = 1,
breed = "offspring")
# Newborn inherit all the data from the parent (female) so we update the sex and color
# Change the sex randomly
allInd <- NLset(turtles = allInd,
agents = NLwith(agents = allInd,
var = "breed",
val = "offspring"),
var = "sex",
val = sample(c("female", "male"),
size = NLcount(NLwith(agents = allInd,
var = "breed",
val = "offspring")),
replace = TRUE))
# Give them the breed "turtle"
allInd <- NLset(turtles = allInd,
agents = NLwith(agents = allInd,
var = "breed",
val = "offspring"),
var = "breed",
val = "turtle")
# Update the colors
allInd <- NLset(turtles = allInd,
agents = NLwith(agents = allInd,
var = "sex",
val = "male"),
var = "color",
val = "red")
allInd <- NLset(turtles = allInd,
agents = NLwith(agents = allInd,
var = "sex",
val = "female"),
var = "color",
val = "black")
# Check population size
expect_equal(popSize + length(whoReproducingFemales),
NLcount(allInd))
# Check there are no more "offspring"
expect_equal(NLcount(NLwith(agents = allInd,
var = "breed",
val = "offspring")),
0)
return(allInd)
}
# Identify when a male and a female are on a patch together
encounter <- function(allInd){
males <- NLwith(agents = allInd,
var = "sex",
val = "male")
females <- NLwith(agents = allInd,
var = "sex",
val = "female")
# Females that are on patches where there are male
femalesWithMales <- turtlesOn(world = w1, turtles = females, agents = males)
whoFemalesWithMales <- of(agents = femalesWithMales, var = "who")
return(whoFemalesWithMales)
}
# Apply the reproduction function in this case
t1 <- popInit
for(timeStep in 1:20){
# Movement
newFemales <- moveFemale(NLwith(agent = t1,
var = "sex",
val = "female"))
newMales <- moveMale(NLwith(agent = t1,
var = "sex",
val = "male"))
expect_equal(NLcount(newFemales) + NLcount(newMales),
NLcount(t1))
# Need to put back together the modified males and females for the next step (updated t1)
t1 <- turtleSet(newFemales,
newMales)
# Reproduction
whoReproducingFemales <- encounter(t1)
if(length(whoReproducingFemales) > 0){
t1 <- reproduction(allInd = t1,
whoReproducingFemales = whoReproducingFemales)
}
}
## EXERCISE 3/3 ##
## Plot and show the evolution of the population
# Plot the world
plot(w1)
# Plot the individuals at each time step
t1 <- popInit
for(timeStep in 1:20){
# Movement
newFemales <- moveFemale(NLwith(agent = t1,
var = "sex",
val = "female"))
newMales <- moveMale(NLwith(agent = t1,
var = "sex",
val = "male"))
expect_equal(NLcount(newFemales) + NLcount(newMales),
NLcount(t1))
# Need to put back together the modified males and females for the next step (updated t1)
t1 <- turtleSet(newFemales,
newMales)
# Reproduction
whoReproducingFemales <- encounter(t1)
if(length(whoReproducingFemales) > 0){
t1 <- reproduction(allInd = t1,
whoReproducingFemales = whoReproducingFemales)
}
# Plot
plot(w1)
points(t1,
pch = 19,
col = of(agents = t1,
var = "color"))
Sys.sleep(1)
print(timeStep)
}
# Count the number of individuals (males and females or both) at each time step
numInd <- rep(NA, 20)
numMale <- rep(NA, 20)
numFemale <- rep(NA, 20)
t1 <- popInit
for(timeStep in 1:20){
# Movement
newFemales <- moveFemale(NLwith(agent = t1,
var = "sex",
val = "female"))
newMales <- moveMale(NLwith(agent = t1,
var = "sex",
val = "male"))
expect_equal(NLcount(newFemales) + NLcount(newMales),
NLcount(t1))
# Need to put back together the modified males and females for the next step (updated t1)
t1 <- turtleSet(newFemales,
newMales)
# Reproduction
whoReproducingFemales <- encounter(t1)
if(length(whoReproducingFemales) > 0){
popSize <- NLcount(t1)
t1 <- reproduction(allInd = t1,
whoReproducingFemales = whoReproducingFemales)
}
# Plot
plot(w1)
points(t1,
pch = 19,
col = of(agents = t1,
var = "color"))
Sys.sleep(1)
print(timeStep)
# Outputs
numInd[timeStep] <- NLcount(t1)
numMale[timeStep] <- NLcount(NLwith(agents = t1,
var = "sex",
val = "male"))
numFemale[timeStep] <- NLcount(NLwith(agents = t1,
var = "sex",
val = "female"))
}
# Plot the number of individuals
plot(1:20,
numInd,
ylim = c(0, max(numInd)),
main = "Number of individuals",
type = "l",
col = "green",
lwd = 2)
lines(1:20,
numMale,
col = "red")
lines(1:20,
numFemale,
col = "black")
legend("topleft",
legend = c("Total ind.", "Males", "Females"),
col = c("green", "red", "black"),
lty = c(1, 1, 1),
lwd = c(2, 1, 1))
library(NetLogoR)
help(createTurtles)
library(NetLogoR)
set.seed(1234) # same seed so that everybody has the same results
rm(list=ls()) # reset the R environment
set.seed(1234) # same seed so that everybody has the same results
help(createWorld)
# Create a forest of 25 cells representing 25 plots where trees can grow
# 1 tree per cell (= patch)
forest <- createWorld(minPxcor = 0,
maxPxcor = 4,
minPycor = 0,
maxPycor = 4)
plot(forest)
help(NLset)
patches(forest)
# sample() (not from NetLogoR) does random sample and permutations
# Examples:
sample(x = 1:10, size = 25, replace = TRUE)
sample(x = 1:10, size = 5, replace = FALSE) # cannot take more than what there is available without replace
# sample() (not from NetLogoR) does random sample and permutations
# Examples:
sample(x = 1:10, size = 25, replace = TRUE)
sample(x = 1:10, size = 5, replace = FALSE) # cannot take more than what there is available without replace
sample(x = 1:10, size = 5, replace = FALSE) # cannot take more than what there is available without replace
sample(x = 1:10, size = 5, replace = FALSE) # cannot take more than what there is available without replace
sample(x = 10, size = 25, replace = TRUE) # carreful ! x = 10 means x = 1:10 !!! Always check x length
sample(x = 1:10,
size = 25,
replace = TRUE)
# Trees are represented by their age (or it can be their size)
# Give a random age (between 1 and 10) to the 25 trees
# NLset() to assign or modify pacthes' value
forest <- NLset(world = forest,
agents = patches(forest),
val = sample(x = 1:10,
size = 25,
replace = TRUE))
forest
# Create a forest of 25 cells representing 25 plots where trees can grow
# 1 tree per cell (= patch)
forest <- createWorld(minPxcor = 0,
maxPxcor = 4,
minPycor = 0,
maxPycor = 4)
forest
plot(forest,
breaks = 0:15, col = rainbow(16)) # keep the same color scale for all plots
# Trees are represented by their age (or it can be their size)
# Give a random age (between 1 and 10) to the 25 trees
# NLset() to assign or modify pacthes' value
forest <- NLset(world = forest,
agents = patches(forest),
val = sample(x = 1:10,
size = 25,
replace = TRUE))
plot(forest,
breaks = 0:15, col = rainbow(16)) # keep the same color scale for all plots
forest
forest
forest@.Data
library(NetLogoR)
rm(list=ls()) # reset the R environment
set.seed(1234) # same seed so that everybody has the same results
# Create a forest of 25 cells representing 25 plots where trees can grow
# 1 tree per cell (= patch)
forest <- createWorld(minPxcor = 0,
maxPxcor = 4,
minPycor = 0,
maxPycor = 4)
plot(forest)
# Trees are represented by their age (or it can be their size)
# Give a random age (between 1 and 10) to the 25 trees
# NLset() to assign or modify pacthes' value
forest <- NLset(world = forest,
agents = patches(forest),
val = sample(x = 1:10,
size = 25,
replace = TRUE))
# sample() (not from NetLogoR) does random sample and permutations
# Examples:
sample(x = 1:10, size = 25, replace = TRUE)
sample(x = 1:10, size = 5, replace = FALSE) # cannot take more than what there is available without replace
sample(x = 10, size = 25, replace = TRUE) # carreful ! x = 10 means x = 1:10 !!! Always check x length
plot(forest,
breaks = 0:15, col = rainbow(16)) # keep the same color scale for all plots
# What's in forest
forest
plot(forest,
breaks = (0:15) + 0.1, col = rainbow(16)) # keep the same color scale for all plots
hepl(of)
help(of)
# Trees grow, their age increment of 1
# First, retrieve their current age
ageTrees <- of(world = forest,
agents = patches(forest))
ageTrees
newAgeTrees <- ageTrees + 1
newAgeTrees
# Then, assign the trees their new age
forest <- NLset(world = forest,
agents = patches(forest),
val = newAgeTrees)
plot(forest,
breaks = 0:15, col = rainbow(16))
help(nOf)
patches(forest)
# Cut 5 trees randomly
# First, select 5 random patches
cutTrees <- nOf(agents = patches(forest),
n = 5)
cutTrees
# Then, put their age at 0
forest <- NLset(world = forest,
agents = cutTrees,
val = 0)
plot(forest,
breaks = 0:15, col = rainbow(16))
library(NetLogoR)
rm(list=ls()) # reset the R environment
# World with a single value per patch: worldMatrix
w1 <- createWorld(minPxcor = 0,
maxPxcor = 4,
minPycor = 0,
maxPycor = 4,
data = runif(25)) # when min and max values are not given, default is min = 0 and max = 1
plot(w1)
w1[1,2]
w1@.Data
w1[2]
w1@.Data[1,2]
w1[1,2]
w1[2]
w1[]
w1[c(2,3)]
w1[c(1,2),3]
## NETLOGOR IN DETAILS ##
library(NetLogoR)
rm(list=ls()) # reset the R environment
# World with a single value per patch: worldMatrix
w1 <- createWorld(minPxcor = 0,
maxPxcor = 4,
minPycor = 0,
maxPycor = 4,
data = runif(25)) # when min and max values are not given, default is min = 0 and max = 1
plot(w1)
w1@minPxcor
w1@maxPxcor
w1@minPycor
w1@maxPycor
w1@extent
w1@res
w1@pCoords
w1@.Data
w1[2,3]
w1@.Data[2,3]
w1@.Data[2,4]
w1[2,4]
w1@.Data[c(1,2),4]
w1[c(1,2),4]
w1[3]
w1[2]
w1[]
w1 <- createWorld(minPxcor = 0,
maxPxcor = 4,
minPycor = 0,
maxPycor = 4,
data = 1:25)
w2 <- createWorld(minPxcor = 0,
maxPxcor = 4,
minPycor = 0,
maxPycor = 4,
data = 25:1)
# Stacking multiple worldMatrix into a worldArray
w3 <- stackWorlds(w1, w2)
w3
plot(w3)
plot(w3[[1]])
plot(w3[[2]])
plot(w3[["w1"]])
plot(w3[["w2"]])
w3@.Data
t1 <- createTurtles(n = 10,
coords = randomXYcor(world = w1,
n = 10))
t1 # factor variables are shown with labels but individuals coordinates are not shown
t1@.Data # individuals coordinates are visible but labels of factor variables are not shown
# Create a new variable
t1 <- turtlesOwn(turtles = t1,
tVar = "sex",
tVal = c("F", "F", "F", "F", "F", "F", "M", "M", "M", "M"))
t1
# Create two types of individuals
# Either create them all in the same agentMatrix
# Create two types of individuals
# Either create them all in the same agentMatrix
t2 <- createTurtles(world = w1,
n = 10,
breed = c(rep("sheep", 5), rep("wolf", 5)))
t2 # both sheep and wolves are in the same object
# You can then separate them with NLwith()
sheep_t2 <- NLwith(agents = t2,
var = "breed",
val = "sheep")
wolves_t2 <- NLwith(agents = t2,
var = "breed",
val = "wolf")
sheep_t2
wolves_t2
# Or create directly 2 different agentMatrix
sheep <- createTurtles(world = w1,
n = 5,
breed = "sheep")
wolves <- createTurtles(world = w1,
n = 5,
breed = "wolf")
# Look at the difference between the 2 ways of creating the individuals
# Compare the sheep
sheep_t2
sheep
# Compare the wolves
wolves_t2
wolves
all()
all(c(TRUE, TRUE, TRUE))
all(c(TRUE, TRUE, FALSE))
all(c(FALSE, FALSE, FALSE))
